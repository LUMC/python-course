\documentclass[aspectratio=1610,slidestop]{beamer}

\author{}
\title{Python Programming}
\providecommand{\mySubTitle}{Functions}
\providecommand{\myConference}{Programming Course}
\providecommand{\myDate}{30-11-2022}
\providecommand{\myGroup}{}
\providecommand{\myDepartment}{}
\providecommand{\myCenter}{}

\usetheme{lumc}

\input{../../shared/shared.tex}

\usepackage[inkscapelatex=false]{svg}
\newcommand{\decl}[1]{\textcolor{blue}{\lstinline{#1}}}


\begin{document}

% This disables the \pause command, handy in the editing phase.
%\renewcommand{\pause}{}

% Make the title slide.
\makeTitleSlide{\includesvg[height=3.5cm]{../../images/Python.svg}}


% First page of the presentation.
\section{Introduction}

\makeTableOfContents

\subsection{ }
\begin{pframe}
 \begin{itemize}
  \item A \empt{function} is a named sequence of statements that performs some
        piece of work.
  \item Later on that function can be called multiple times by using its name.
 \end{itemize}
\end{pframe}


\section{User Defined Functions}

\subsection{Defining a function}
\begin{pframe}
 A function definition includes its \decl{name}, \decl{parameters} (optional), and \decl{body}:
 \begin{pythondeclaration}
  \emp{def}\textvisiblespace\decl{name}\emp{(}\decl{parameters}\emp{):}\\
  \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace\decl{body}
 \end{pythondeclaration}
 \pause
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def greeting():
    print('Hello!')
  \end{minted}
 \end{pythonfile}
\end{pframe}


\subsection{Calling a function}
\begin{pframe}
 A function is called by using its \decl{name} and by providing the required
 \decl{arguments}:
 \begin{pythondeclaration}
  \decl{name}\emp{(}\decl{arguments}\emp{)}
 \end{pythondeclaration}
 \pause
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def greeting():
    print('Hello!')

greeting()
  \end{minted}
 \end{pythonfile}
\end{pframe}


\begin{pframe}
 A function is called by using its \decl{name} and by providing the required
 \decl{arguments}:
 \begin{pythondeclaration}
  \decl{name}\emp{(}\decl{arguments}\emp{)}
 \end{pythondeclaration}
 \vspace{0.1cm}
 \begin{minipage}[t]{0.47\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def greeting():
    print('Hello!')

greeting()
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.47\textwidth}
 \vspace{-2.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python functions.py \\
Hello!}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 A function is called by using its \decl{name} and by providing the required
 \decl{arguments}:
 \begin{pythondeclaration}
  \decl{name}\emp{(}\decl{arguments}\emp{)}
 \end{pythondeclaration}
 Now let's add some \decl{parameters}:
 \vspace{0.1cm}

 \begin{minipage}[t]{0.49\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def greeting(name):
    print('Hello {}!'.format(name))

greeting('students')
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.47\textwidth}
 \vspace{-2.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python functions.py \\
Hello students !}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{The \emp{return} statement}

\begin{pframe}
 Used mainly to \emp{return} a certain result value back to the caller.
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2
  \end{minted}
 \end{pythonfile}
\end{pframe}


\begin{pframe}
 Used mainly to \emp{return} a certain result value back to the caller.
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

print(add_two(5))
  \end{minted}
 \end{pythonfile}
\end{pframe}


\begin{pframe}
 Used mainly to \emp{return} a certain result value back to the caller.
 \medskip

 \begin{minipage}[t]{0.47\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

print(add_two(5))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.47\textwidth}
 \vspace{-2.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python functions.py \\
7}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 Used mainly to \emp{return} a certain result value back to the caller.
 \medskip

 \begin{minipage}[t]{0.60\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

for i in range(5):
    print('{} -> {}'.format(i, add_two(i)))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.35\textwidth}
 \vspace{-3.05cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python functions.py \\
0 -> 2\\
1 -> 3\\
2 -> 4\\
3 -> 5\\
4 -> 6}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \begin{itemize}
  \item Functions immediately \empt{exit} when a \emp{return} statement is encountered.
  \item No explicit value needs to be mentioned in the \emp{return} statement.
 \end{itemize}
 \pause
 \medskip

 \begin{minipage}[t]{0.49\textwidth}
  \begin{pythonfile}{negative.py}
   \begin{minted}[linenos]{python}
def first_negative(numbers):
  for n in numbers:
     if n < 0:
       print(n)
       return
  print("No negative number found!")

first_negative([3, -5, 10, -2])
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.45\textwidth}
 \vspace{-4.15cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python negative.py \\
-5}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \begin{itemize}
  \item Something is always returned.
 \end{itemize}
 \medskip

 \begin{minipage}[t]{0.52\textwidth}
  \begin{pythonfile}{negative.py}
   \begin{minted}[linenos]{python}
def first_negative(numbers):
  for n in numbers:
     if n < 0:
       print(n)
       return
  print("No negative number found!")

first_negative([3, -5, 10, -2])
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.42\textwidth}
 \vspace{-4.15cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python negative.py \\
-5
}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{itemize}
  \item Something is always returned.
 \end{itemize}
 \medskip

 \begin{minipage}[t]{0.52\textwidth}
  \begin{pythonfile}{negative.py}
   \begin{minted}[linenos]{python}
def first_negative(numbers):
  for n in numbers:
     if n < 0:
       print(n)
       return
  print("No negative number found!")

print(first_negative([3, -5, 10, -2]))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.42\textwidth}
 \vspace{-4.15cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python negative.py \\
-5\\
None}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \begin{itemize}
  \item Something is always returned, even if no \emp{return} statement is reached.
 \end{itemize}
 \medskip

 \begin{minipage}[t]{0.52\textwidth}
  \begin{pythonfile}{negative.py}
   \begin{minted}[linenos]{python}
def first_negative(numbers):
  for n in numbers:
     if n < 0:
       print(n)
       return
  print("No negative number found!")

print(first_negative([]))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.42\textwidth}
 \vspace{-4.15cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python negative.py \\
No negative number found!\\
None}}
 \end{terminal}
 \end{minipage}
\end{pframe}



\section{Arguments}

\subsection{Required}
\begin{pframe}
  Have to be passed during the function call (precisely in the right order).
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

print(add_two())
  \end{minted}
 \end{pythonfile}
 \pause
 \begin{terminal}
  \color{white}{\texttt{\$ python functions.py \\
  File "functions.py", line 4, in <module>\\
    add\_two()\\
TypeError: add\_two() missing 1 required positional argument: 'number'
}}
 \end{terminal}
\end{pframe}


\subsection{Default}
\begin{pframe}
 Have a default value if no argument value is passed during the function call.
 \medskip

 \begin{minipage}[t]{0.47\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def add_value(number, default=2):
    return number + default

print(add_value(5))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.47\textwidth}
  \vspace{-2.6cm}
  \begin{terminal}
   \color{white}{\texttt{\$ python functions.py \\
7
}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 Have a default value if no argument value is passed during the function call.
 \medskip

 \begin{minipage}[t]{0.47\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def add_value(number, default=2):
    return number + default

print(add_value(5))
print(add_value(5, 5))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.47\textwidth}
  \vspace{-3.05cm}
  \begin{terminal}
   \color{white}{\texttt{\$ python functions.py \\
7\\
10
}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{Explicit parameter mentioning}
\begin{pframe}
 When you want to make sure that the mapping is correct.
 \medskip

 \begin{minipage}[t]{0.51\textwidth}
  \begin{pythonfile}{functions.py}
   \begin{minted}[linenos]{python}
def add_value(number, default=2):
    return number + default

print(add_value(5, default=2))
print(add_value(number=5, default=2))
print(add_value(default=2, number=5))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \begin{minipage}[t]{0.43\textwidth}
  \vspace{-3.45cm}
  \begin{terminal}
   \color{white}{\texttt{\$ python functions.py \\
7\\
7\\
7}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\section{Variables Scope}

\begin{pframe}
 Scope refers to the variables visibility, i.e., in which program parts can be seen and used.
 \medskip
 \pause

  Roughly speaking:
  \begin{itemize}
   \item The whole program (module) forms one scope.
   \item A function definition creates a new (nested) scope.
 \end{itemize}
 \begin{tikzpicture}[remember picture,overlay]
   \node[xshift=-3.2cm,yshift=-5.5cm] at (current page.north east)
    {\includesvg[width=4cm]{../../images/scope_overview_0.svg}};
 \end{tikzpicture}
\end{pframe}


\begin{pframe}
 \addtocounter{framenumber}{-1}
 Scope refers to the variables visibility, i.e., in which program parts can be seen and used.
 \medskip

  Roughly speaking:
  \begin{itemize}
   \item The whole program (module) forms one scope.
   \item A function definition creates a new (nested) scope.
   \item Variables from an outside scope are visible in the \\
         inner nested scope, but you cannot (re)-assign a value\\
         to them (read only) unless they are declared global.
 \end{itemize}
 \begin{tikzpicture}[remember picture,overlay]
   \node[xshift=-3.2cm,yshift=-5.5cm] at (current page.north east)
    {\includesvg[width=4cm]{../../images/scope_overview_1.svg}};
 \end{tikzpicture}
\end{pframe}


\begin{pframe}
 \addtocounter{framenumber}{-1}
 Scope refers to the variables visibility, i.e., in which program parts can be seen and used.
 \medskip

  Roughly speaking:
  \begin{itemize}
   \item The whole program (module) forms one scope.
   \item A function definition creates a new (nested) scope.
   \item Variables from an outside scope are visible in the \\
         inner nested scope, but you cannot (re)-assign a value\\
         to them (read only) unless they are declared global.
   \item Variables inside a nested scope are not visible in \\
         the outer scope.
 \end{itemize}
 \begin{tikzpicture}[remember picture,overlay]
   \node[xshift=-3.2cm,yshift=-5.5cm] at (current page.north east)
    {\includesvg[width=4cm]{../../images/scope_overview_2.svg}};
 \end{tikzpicture}
\end{pframe}


\begin{pframe}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_0.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_1.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_2.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_3.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_4.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_5.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_6.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_7.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \addtocounter{framenumber}{-1}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/scope_8.svg}
 \end{center}
\end{pframe}


\subsection{Hiding variables}
\begin{pframe}
 If in a new scope a variable is created that already exists in an outer scope,
 the new variable will hide the outer variable.
 \pause
 \medskip

 \begin{minipage}[t]{0.60\textwidth}
  \begin{pythonfile}{scope\_hiding.py}
   \begin{minted}[linenos]{python}
a = 1

def some_function():
    a = 2 # Hides the global a variable
    print(a)

# Calling the function
some_function()
print(a)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.35\textwidth}
 \vspace{-4.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python scope\_hiding.py \\
2\\
1
}}
  \end{terminal}
 \end{minipage}
 \pause
 \smallskip

  This applies to function parameters as well.
\end{pframe}


\subsection{The \emp{global} keyword}
\begin{pframe}
 Allows a variable to be changed outside of the current scope.
 \pause
 \medskip

 \begin{minipage}[t]{0.60\textwidth}
  \begin{pythonfile}{global.py}
   \begin{minted}[linenos]{python}
a = 1

def some_function():
    global a  # a is the global one
    a = 2
    print(a)

# Calling the function
some_function()
print(a)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.35\textwidth}
 \vspace{-4.95cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python global.py \\
2\\
2
}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{What about parameters and arguments?}
\begin{pframe}
 \begin{minipage}[t]{0.50\textwidth}
  \begin{pythonfile}{parameters.py}
   \begin{minted}[linenos]{python}
def some_function(b):
    b = 2
    print(b)

a = 1

print(a)

# Calling the function
some_function(a)

print(a)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.45\textwidth}
 \vspace{-5.65cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python parameters.py \\
1\\
2\\
1
}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{Mutable arguments}
\begin{pframe}
 \begin{minipage}[t]{0.50\textwidth}
  \begin{pythonfile}{mutable\_params.py}
   \begin{minted}[linenos]{python}
def some_function(a_list):
    a_list = 13
    print('a_list:', a_list)

a = [7, 5]

print('a before the call:', a)

# Calling the function
some_function(a)

print('a after the call:', a)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.45\textwidth}
 \vspace{-5.65cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python mutable\_params.py \\
a before the call: [7, 5]\\
a\_list: 13\\
a after the call: [7, 5]
}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 However, element changes to update the argument.
 \medskip

 \begin{minipage}[t]{0.50\textwidth}
  \begin{pythonfile}{mutable\_params.py}
   \begin{minted}[linenos]{python}
def some_function(a_list):
    a_list[1] = 13
    print('a_list:', a_list)

a = [7, 5]

print('a before the call:', a)

# Calling the function
some_function(a)

print('a after the call:', a)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.45\textwidth}
 \vspace{-5.65cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python mutable\_params.py \\
a before the call: [7, 5]\\
a\_list: [7, 13]\\
a after the call: [7, 13]
}}
  \end{terminal}
 \end{minipage}
\end{pframe}



\section{Function as Values}

\begin{pframe}
\vspace{-0.5cm}
 We can pass functions around just like other values, and call them.
 \begin{pythonfile}{function\_values.py}
  \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

def add_some_other_number(number, other_number=12):
    return number + other_number

functions = [add_two, add_some_other_number]
for function in functions:
    print(function(7))
  \end{minted}
 \end{pythonfile}
 \pause
 \begin{terminal}
  \color{white}{\texttt{\$ python function\_values.py \\
9\\
19
}}
 \end{terminal}
\end{pframe}



\section{Docstrings}
\begin{pframe}
 \vspace{-1.1cm}
 \begin{itemize}
  \item Regular string values which you start the function definition body with.
  \item You can access a docstring using the \emp{help()} built-in.
 \end{itemize}
 \vspace{-0.3cm}
 \begin{pythonfile}{docstrings.py}
  \begin{minted}[linenos]{python}
def factorial(n):
    """Compute factorial of n in the obvious way."""
    if n == 0:
        return 1
    else:
        return factorial(n - 1) * n

help(factorial)
  \end{minted}
 \end{pythonfile}
 \pause
 \begin{terminal}
  \color{white}{\texttt{\$ python docstrings.py \\
Help on function factorial in module \_\_main\_\_:\\
factorial(n)\\
    Compute factorial of n in the obvious way.
}}
 \end{terminal}
\end{pframe}

\section{Higher Order Functions}
\begin{pframe}
 Take a function as an argument.
 \begin{ipython}
  \begin{pythonin}{python}
help(map)
Help on class map in module builtins:
class map(object)
 |  map(func, *iterables) --> map object
 |
 |  Make an iterator that computes the function using arguments from
 |  each of the iterables.  Stops when the shortest iterable is
 |  exhausted.
  \end{pythonin}
  \\

 \begin{pythonin}{python}
list(map(add_two, [1, 2, 3, 4]))
  \end{pythonin}
  \\
  \begin{pythonout}
[3, 4, 5, 6]
  \end{pythonout}
 \end{ipython}
\end{pframe}



\section{Anonymous Functions}

% \begin{pframe}
%  Can be created with the \emp{lambda} keyword:
%  \begin{pythondeclaration}
%   \emp{lambda}\textvisiblespace\decl{parameters}\emp{:}\textvisiblespace
%   \decl{expression}
%  \end{pythondeclaration}
%  \bigskip
%
%  \begin{minipage}[t]{0.57\textwidth}
%   \begin{pythonfile}{anonymous.py}
%    \begin{minted}[linenos]{python}
% x_times_7 = lambda x: x * 7
% print(x_times_7(4))
%
% l = list(map(lambda x: x+2, [1, 2, 3, 4]))
% print(l)
%    \end{minted}
%   \end{pythonfile}
%  \end{minipage}\qquad
%  \pause
%  \begin{minipage}[t]{0.37\textwidth}
%  \begin{terminal}
%   \color{white}{\texttt{\$ python anonymous.py \\
% 28\\
% [3, 4, 5, 6]
% }}
%  \end{terminal}
%  \end{minipage}
% \end{pframe}


\begin{pframe}
 Can be created with the \emp{lambda} keyword:
 \begin{pythondeclaration}
  \emp{lambda}\textvisiblespace\decl{parameters}\emp{:}\textvisiblespace
  \decl{expression}
 \end{pythondeclaration}
 \bigskip

 \begin{minipage}[t]{0.47\textwidth}
  \begin{pythonfile}{anonymous.py}
   \begin{minted}[linenos]{python}
x_times_7 = lambda x: x * 7
print(x_times_7(4))
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.47\textwidth}
%  \vspace{-2.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python anonymous.py \\
28}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 Can be created with the \emp{lambda} keyword:
 \begin{pythondeclaration}
  \emp{lambda}\textvisiblespace\decl{parameters}\emp{:}\textvisiblespace
  \decl{expression}
 \end{pythondeclaration}
 \bigskip

 \begin{minipage}[t]{0.60\textwidth}
 \vspace{-3.25cm}
  \begin{pythonfile}{anonymous.py}
   \begin{minted}[linenos]{python}
x_times_7 = lambda x: x * 7
print(x_times_7(4))

for i in list(map(lambda x: x+2, range(4))):
    print(i)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
 \pause
 \begin{minipage}[t]{0.35\textwidth}
%  \vspace{-2.55cm}
 \begin{terminal}
  \color{white}{\texttt{\$ python anonymous.py \\
28\\
2\\
3\\
4\\
5
}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\section*{Wrap up}

\begin{pframe}
 You are now able to:
 \begin{itemize}
  \item Create yout own user defined functions.
  \item Call your defined functions with the right arguments.
  \item Understand variables scope.
  \item Write docstrings for your functions.
  \item Use higher order functions.
  \item Employ anonymous functions.
 \end{itemize}

\end{pframe}


\section{Hands On!}

\begin{pframe}
 \vspace{-0.5cm}
 \begin{enumerate}
  \item Write a Python function that returns the maximum of two numbers.
  \item Write a Python function that returns the maximum of three numbers.
  Try to reuse the first maximum of two numbers function.
  \item Write a Python function that accepts a list as a parameter.
  Next, it determines and prints the number of positive and negative numbers.
 \end{enumerate}
\end{pframe}


% Make the acknowledgements slide.
\makeAcknowledgementsSlide{
  \begin{tabular}{ll}
    Martijn Vermaat\\
    Jeroen Laros\\
    Jonathan Vis
  \end{tabular}
}

\end{document}
