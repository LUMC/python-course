\documentclass[aspectratio=1610,t]{beamer}

\author{Mihai Lefter}
\title{Python Programming}
\providecommand{\mySubTitle}{Flow Control}
\providecommand{\myConference}{Programming Course}
\providecommand{\myDate}{26-11-2019}
\providecommand{\myGroup}{}
\providecommand{\myDepartment}{}
\providecommand{\myCenter}{}

\usetheme{lumc}

\input{../../shared/shared.tex}

\usepackage{booktabs}
\usepackage[inkscapelatex=false]{svg}

\begin{document}

% This disables the \pause command, handy in the editing phase.
%\renewcommand{\pause}{}

% Make the title slide.
\makeTitleSlide{\includesvg[height=3.5cm]{../../images/Python.svg}}

% First page of the presentation.
\section{Introduction}
\makeTableOfContents



\section{Sequential Execution}

\begin{pframe}
 \begin{center}
  \includesvg[width=0.25\textwidth]{../../images/flow_sequential.svg}
 \end{center}
\end{pframe}


\begin{pframe}
 \begin{minipage}{0.37\textwidth}
  \begin{center}
   \includesvg[width=0.5\textwidth]{../../images/flow_sequential.svg}
  \end{center}
 \end{minipage}%
 \begin{minipage}{0.57\textwidth}
  \begin{pythonfile}{sum.py}
   \begin{minted}[linenos]{python}
a = 100
b = 200
print(a+b)
   \end{minted}
  \end{pythonfile}
 \begin{terminal}
  \color{white}{\texttt{\$ python sum.py \\
300}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{Intermezzo - User input}
\begin{pframe}
Performed with the \emp{input([prompt])} built-in function:
 \begin{itemize}
  \item If the \emp{prompt} argument is present, it is written to the standard
        output.
  \item The user input is then read as a string.
 \end{itemize}
 \pause
 \begin{pythonfile}{sum.py}
  \begin{minted}[linenos]{python}
a = input('a = ')
b = input('b = ')
print(a+b)
  \end{minted}
 \end{pythonfile}
 \pause
 \begin{terminal}
  \color{white}{\texttt{\$ python sum.py \\
a = 100 \\
b = 200 \\
100200}}
 \end{terminal}
 \pause
 \begin{tikzpicture}[remember picture,overlay]
   \node[xshift=-6.5cm,yshift=-6.64cm] at (current page.north east)
   {\includesvg[width=5.8cm]{../../images/questions.svg}};
 \end{tikzpicture}
\end{pframe}


\begin{pframe}
Performed with the \emp{input([prompt])} built-in function:
 \begin{itemize}
  \item If the \emp{prompt} argument is present, it is written to the standard
        output.
  \item The user input is then read as a \empt{string}.
 \end{itemize}
 \begin{pythonfile}{sum.py}
  \begin{minted}[linenos]{python}
a = int(input('a = '))
b = int(input('b = '))
print(a+b)
  \end{minted}
 \end{pythonfile}
 \begin{terminal}
  \color{white}{\texttt{\$ python sum.py \\
a = 100 \\
b = 200 \\
300}}
 \end{terminal}
\end{pframe}


\subsection{Intermezzo - Comments}
\begin{pframe}
 Comments are prepended by \emp{\#} and completely ignored.
 \begin{pythonfile}{sum.py}
  \begin{minted}[linenos]{python}
# Retrieve the input
a = int(input('a = '))
b = int(input('b = '))

# Compute and display the result
print(a+b)
  \end{minted}
 \end{pythonfile}
\end{pframe}


\section{Conditionals}

\begin{pframe}
 \begin{center}
  \includesvg[width=0.55\textwidth]{../../images/flow_conditional.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \begin{center}
  \includesvg[width=0.55\textwidth]{../../images/flow_conditional_if_only.svg}
 \end{center}
\end{pframe}

\begin{pframe}
 \begin{center}
  \includesvg[width=0.75\textwidth]{../../images/flow_conditional_chained_if.svg}
 \end{center}
\end{pframe}


\subsection{Truth Value Testing}
\begin{pframe}
%  Any object can be tested for its \textbf{truth} value:
 \begin{itemize}
 \item Built-in objects considered \textcolor{red}{false}:
 \begin{itemize}
   \item constants defined to be \textcolor{red}{false}: \emp{None} and \emp{False}.
   \pause
   \item zero of any numeric type: \emp{0}, \emp{0.0}, \emp{0j},
         \emp{Decimal(0)}, \emp{Fraction(0, 1)}.
   \pause
   \item empty sequences and collections: \emp{''}, \emp{()}, \emp{[]},
         \emp{\{\}}, \emp{set()}, \emp{range(0)}.
  \end{itemize}
  \pause
  \item For the moment, let's assume that any other object is considered
  \textcolor{green}{true}.
 \end{itemize}
 \pause
 \begin{ipython}
  \begin{pythonin}{python}
bool(0)
  \end{pythonin}
  \begin{pythonout}
False
  \end{pythonout}\\ \\
  \begin{pythonin}{python}
bool(1)
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout}\\ \\
  \begin{pythonin}{python}
bool([False])
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout}
 \end{ipython}
\end{pframe}


\subsection{Comparisons}
\begin{pframe}
 \begin{table}[]
  \begin{tabular}{@{}lll@{}}
   \toprule
   Operation    & Meaning & Example \\ \toprule
   \emp{<}      & strictly less than & \pythoninline{x < y} \\
   \emp{<=}     & less than or equal & \pythoninline{x <= y} \\
   \emp{>}      & strictly greater than & \pythoninline{x > y} \\
   \emp{>=}     & greater than or equal & \pythoninline{x >= y} \\
   \emp{==}     & equal & \pythoninline{x == y} \\
   \emp{!=}     & not equal & \pythoninline{x != y} \\ \midrule
   \emp{is}     & object identity & \pythoninline{x is y} \\
   \emp{is not} & negated object identity & \pythoninline{x is not y} \\ \bottomrule
  \end{tabular}
 \end{table}
\end{pframe}


\begin{pframe}
 \begin{ipython}
  \begin{pythonin}{python}
3 < 4
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout} \\ \\
  \begin{pythonin}{python}
3 <= 3.5
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout} \\ \\
  \begin{pythonin}{python}
3 == 3.0
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout}
 \\ \\
  \begin{pythonin}{python}
3 is 3.0
  \end{pythonin}
  \begin{pythonout}
False
  \end{pythonout} \\ \\
  \begin{pythonin}{python}
3 is 3
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout}
 \end{ipython}
\end{pframe}


\subsection{Boolean (Logical) Operations}
\begin{pframe}
 \begin{table}[]
  \begin{tabular}{@{}llc@{}}
   \toprule
   Operation     & Result & Notes \\ \midrule
   \pythoninline{x or y}  & if \emp{x} is false, then \emp{y}, else \emp{x} & (1) \\
   \pythoninline{x and y} & if \emp{x} is false, then \emp{x}, else \emp{y} & (2) \\
   \pythoninline{not x}   & if \emp{x} is false, then \emp{True}, else \emp{False} & (3) \\ \bottomrule
  \end{tabular}
 \end{table}
 \begin{enumerate}
  \item It evaluates \emp{y} only if \emp{x} is false.
  \item It evaluates \emp{y} only if \emp{x} is true.
  \item \pythoninline{not x == y} is interpreted as \pythoninline{not (x == y)}
  and \pythoninline{x == not y} is a syntax error.
 \end{enumerate}
\end{pframe}


\begin{pframe}
 \begin{table}[]
  \begin{tabular}{@{}cc|cc@{}}
   \toprule
   \emp{x}     & \emp{y}     & \emp{x or y} & \emp{x and y} \\ \midrule
   \emp{True}  & \emp{True}  & \emp{True}   & \emp{True}    \\
   \emp{True}  & \emp{False} & \emp{True}   & \emp{False}   \\
   \emp{False} & \emp{True}  & \emp{True}   & \emp{False}   \\
   \emp{False} & \emp{False} & \emp{False}   & \emp{False}  \\ \bottomrule
  \end{tabular}
 \end{table}
\end{pframe}


\begin{pframe}
 \begin{ipython}
  \begin{pythonin}{python}
3 < 4 and 5 <= 10
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout} \\ \\
  \begin{pythonin}{python}
3 < 4 or 5 <= 10
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout} \\ \\
  \begin{pythonin}{python}
3 < 4 and 5 > 10
  \end{pythonin}
  \begin{pythonout}
False
  \end{pythonout}
 \\ \\
  \begin{pythonin}{python}
3 < 4 and 5 > 10
  \end{pythonin}
  \begin{pythonout}
True
  \end{pythonout}
 \end{ipython}
\end{pframe}


\subsection{\emp{if} statement}
\begin{pframe}
 \begin{minipage}{0.47\textwidth}
 \begin{center}
  \includesvg[width=0.80\textwidth]{../../images/flow_conditional.svg}
 \end{center}
 \end{minipage}%
 \begin{minipage}{0.47\textwidth}
  \begin{pythondeclaration}
   \emp{if}\textvisiblespace\lstinline{condition}\emp{:}\\
   \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace
   \lstinline{task 2}\\
   \emp{else:}\\
   \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace
   \lstinline{task 3}
  \end{pythondeclaration}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \begin{minipage}[t]{0.47\textwidth}
 \begin{center}
  \includesvg[width=0.80\textwidth]{../../images/flow_conditional.svg}
 \end{center}
 \end{minipage}\qquad%
 \begin{minipage}[t]{0.47\textwidth}
 \begin{pythonfile}{max.py}
  \begin{minted}[linenos]{python}
a = int(input('a = '))
b = int(input('b = '))

if a > b:
    print(a)
else:
    print(b)
  \end{minted}
 \end{pythonfile}

 \begin{terminal}
  \color{white}{\texttt{\$ python max.py \\
a = 100 \\
b = 200 \\
200}}
 \end{terminal}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \vspace{-0.5cm}
 \begin{minipage}[t]{0.57\textwidth}
  \begin{center}
   \includesvg[width=0.90\textwidth]{../../images/flow_conditional_chained_if.svg}
  \end{center}
 \end{minipage}%
 \begin{minipage}[t]{0.37\textwidth}
  \begin{pythonfile}{compare.py}
   \begin{minted}[linenos]{python}
a = int(input('a = '))
b = int(input('b = '))

if a > b:
    print(a)
elif a == b:
    print('equal')
else:
    print(b)
   \end{minted}
  \end{pythonfile}
  \begin{terminal}
  \color{white}{\texttt{\$ python compare.py \\
a = 100 \\
b = 100 \\
equal}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\section{Indentation}
\begin{pframe}
 Python uses indentation to delimit blocks
 \begin{itemize}
   \item Instead of \emp{begin ... end} or \emp{\{ ... \}} in other languages.
   \item Always increase indentation by 4 spaces, never use tabs.
   \begin{itemize}
     \item In any case, be consistent.
   \end{itemize}
 \end{itemize}
 \begin{pythonfile}{indentation\_example.py}
  \begin{minted}[linenos]{python}
if False:
    if False:
        print('Why am I here?')
    else:
        while True:
            print('When will it stop?')
    print("And we're back to the first indentation level")
  \end{minted}
 \end{pythonfile}
\end{pframe}



\section{Loops}

\begin{pframe}
 \begin{center}
  \includesvg[width=0.50\textwidth]{../../images/flow_loops.svg}
 \end{center}
\end{pframe}


\subsection{\pythoninline{while} statement}
\begin{pframe}
 \begin{minipage}{0.47\textwidth}
 \begin{center}
  \includesvg[width=0.80\textwidth]{../../images/flow_loops.svg}
 \end{center}
 \end{minipage}%
 \begin{minipage}{0.47\textwidth}
  \begin{pythondeclaration}
   \emp{while}\textvisiblespace\lstinline{condition}\emp{:}\\
   \textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace
   \lstinline{task 2}
  \end{pythondeclaration}
 \end{minipage}
\end{pframe}


\begin{pframe}
 \begin{minipage}{0.47\textwidth}
  \begin{center}
   \includesvg[width=0.80\textwidth]{../../images/flow_loops.svg}
  \end{center}
 \end{minipage}%
 \begin{minipage}{0.47\textwidth}
  \begin{pythonfile}{while\_example.py}
   \begin{minted}[linenos]{python}
i = 0
while i < 5:
    print(i)
    i += 1
   \end{minted}
  \end{pythonfile}
  \begin{terminal}
  \color{white}{\texttt{\$ python while\_example.py \\
0\\
1\\
2\\
3\\
4}}
  \end{terminal}
 \end{minipage}
\end{pframe}


\subsection{Infinite loop}
\begin{pframe}
 \begin{pythonfile}{infinite\_loop.py}
  \begin{minted}[linenos]{python}
while True:
    print('yes')
  \end{minted}
 \end{pythonfile}
 \begin{terminal}
  \color{white}{\texttt{\$ python infinite\_loop.py \\
yes\\
yed\\
yes\\
yes\\
...}}
 \end{terminal}
\end{pframe}



\subsection{\pythoninline{for} statement}
\begin{pframe}
 Used to iterate over a sequence.
 \begin{pythonfile}{for\_example.py}
  \begin{minted}[linenos]{python}
colors = ['red', 'white', 'blue', 'orange']

for color in colors:
    print(color)
  \end{minted}
 \end{pythonfile}
 \pause
 \begin{terminal}
  \color{white}{\texttt{\$ python for\_example.py\\
red\\
white\\
blue\\
orange
}}
 \end{terminal}
\end{pframe}


\subsection{Python anti-patterns}
\begin{pframe}
 \begin{minipage}[t]{0.48\textwidth}
  These are common for programmers coming from other languages.
  \begin{pythonfile}{unpythonic.py}
   \begin{minted}[linenos]{python}
colors = ['red', 'white', 'blue']

i = 0
while i < len(colors):
    print(colors[i])
    i += 1

for i in range(len(colors)):
    print(colors[i])
   \end{minted}
  \end{pythonfile}
  We call them unpythonic.
 \end{minipage}\qquad%
 \pause
 \begin{minipage}[t]{0.48\textwidth}
  The Pythonic way:
  \begin{pythonfile}{for\_example.py}
   \begin{minted}[linenos]{python}
colors = ['red', 'white', 'blue']

for color in colors:
    print(color)
   \end{minted}
  \end{pythonfile}
 \end{minipage}\qquad
\end{pframe}


\subsection{\emp{break} and \emp{continue} statements}
\begin{pframe}
 \pause
 \begin{minipage}[t]{0.48\textwidth}
%   Immediately drop out of the loop.
  \emp{break} will immediately exit a loop.
  \begin{pythonfile}{break\_example.py}
   \begin{minted}[linenos]{python}
# Print up to the first negative
for i in [6, 3, -1, 7, -2, 5]:
    if i < 0:
        break
    print(i)
   \end{minted}
  \end{pythonfile}
  \pause
  \begin{terminal}
  \color{white}{\texttt{\$ python break\_example.py \\
6\\
3}}
  \end{terminal}
 \end{minipage}\qquad%
 \pause
 \begin{minipage}[t]{0.48\textwidth}
 \emp{continue} will skip the current block.
  \begin{pythonfile}{continue\_example.py}
   \begin{minted}[linenos]{python}
# Print only positive numbers
for i in [6, 3, -1, 7, -2, 5]:
    if i < 0:
        continue
    print(i)
   \end{minted}
  \end{pythonfile}
  \pause
  \begin{terminal}
  \color{white}{\texttt{\$ python continue\_example.py \\
6\\
3\\
7\\
5
}}
  \end{terminal}
 \end{minipage}\qquad
\end{pframe}


\subsection{Additionals}
\begin{pframe}
 \begin{pythonfile}{iteration.py}
  \begin{minted}[linenos]{python}
# Iteration with values and indices:
for i, color in enumerate(['red', 'yellow', 'blue']):
    print(i, '->', color)

# Taking two sequences together:
for city, population in zip(['Delft', 'Leiden'], [101030, 121562]):
    print(city, '->', population)

# Iterating over a dictionary yields keys:
for key in {'a': 33, 'b': 17, 'c': 18}:
    print(key)

# Iterating over a file yields lines:
for line in open('data/short_file.txt'):
    print(line)
  \end{minted}
 \end{pythonfile}
\end{pframe}


\subsection{The \emp{pass} statement}
\begin{pframe}
 If you need a statement syntactically, but don't want to do anything yet, use \emp{pass}:
 \begin{pythonfile}{pass\_statement.py}
  \begin{minted}[linenos]{python}
age = int(input('Please enter your age: '))

if age < 18:
    # This is to be decided.
    pass
else:
    print('You can apply for a driver\'s permit in most of the countries.')
  \end{minted}
 \end{pythonfile}
\end{pframe}



\section{Comprehensions}

\subsection{Lists}
\begin{pframe}
 Similar to mathematical set notation (e.g., ${x | x \in R \wedge x>0}$), we can create lists.
 \begin{ipython}
  \begin{pythonin}{python}
[(x, x * x) for x in range(10) if x % 2]
  \end{pythonin}
  \begin{pythonout}
[(1, 1), (3, 9), (5, 25), (7, 49), (9, 81)]
  \end{pythonout}
 \end{ipython}
\end{pframe}


\subsection{Sets and dictionaries}
\begin{pframe}
 \begin{ipython}
  \begin{pythonin}{python}
{c for c in 'LUMC-standard' if 'a' <= c <= 'z'}
  \end{pythonin}
  \begin{pythonout}
{'a', 'd', 'n', 'r', 's', 't'}
  \end{pythonout}
 \end{ipython}
\end{pframe}


\subsection{Dictionaries}
\begin{pframe}
 \begin{ipython}
  \begin{pythonin}{python}
colors = ['red', 'white', 'blue', 'orange']
  \end{pythonin}
  \\
  \begin{pythonin}{python}
{c: len(c) for c in colors}
  \end{pythonin}
  \begin{pythonout}
\{'blue': 4, 'orange': 6, 'red': 3, 'white': 5\}
  \end{pythonout}
 \end{ipython}
\end{pframe}



\section*{Extra}

\subsection{Python \emp{print}}
\begin{pframe}
 \begin{ipython}
  \begin{pythonin}{python}
print('{} {}'.format('one', 'two'))
  \end{pythonin}
  \begin{pythonout}
one two
  \end{pythonout}
 \end{ipython}
 \bigskip

 More information:
 \begin{itemize}
  \item \hrefc{linkc}{https://pyformat.info/}{https://pyformat.info/}
 \end{itemize}
\end{pframe}


\section{Hands on!}
\begin{pframe}
 \vspace{-0.5cm}
 Write a python program for each of the following exercises:
\begin{enumerate}
  \item \textbf{Special numbers} \\
        Print only those numbers which are divisible by \emp{13} and multiple of
        \emp{5}, between \emp{10} and \emp{1313} (both included).
  \item \textbf{Bank account simulator} \\
        Take as input an initial bank account balance (e.g., \emp{1000}). Next,
        accept inputs consisting of either expenses (e.g., \emp{-13.99}) or
        revenues (e.g., \emp{20}) until the user introduces \emp{exit}.
        After each input, in case the balance is about to go negative, print an
        error message (e.g., \emp{Operation not permitted: insufficient
        funds.}). Otherwise, print the new balance value.
 \end{enumerate}
\end{pframe}

\end{document}
